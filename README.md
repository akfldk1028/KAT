# AI_DEV_SPEC.md — Kanana DualGuard POC (Purpose-First Spec)

> 이 문서는 **“무엇을 만들 것인가”를 최우선**으로 설명한다.  
> 디렉터리 구조나 세부 구현 방식은 **부차적**이며,  
> 핵심은 “사용자 경험과 시스템의 목적”을 정확히 재현하는 것이다.
> 가상환경필수 !
---

## 0. 역할 및 제약 (Role & Constraints)

당신의 역할:

- **시니어 풀스택 엔지니어**이자 **제품 구현자**로서,  
  이 문서에 정의된 **목적·사용자 경험·행동 원칙**을 기반으로 Kanana DualGuard POC를 설계·구현한다.
- 이 문서가 설명하는 **“사용자가 어떤 상황에서 어떤 도움을 받는지”**를 먼저 이해하고,  
  그 경험을 가장 잘 실현하는 방식으로 기술 스택과 구조를 선택한다.
- 디렉터리 구조, 파일 이름, 프레임워크 세부 사용 방식은 **자유**지만,  
  시스템의 행동이 이 문서의 요구사항과 모순되어서는 안 된다.

기술 제약(최소):

- 백엔드: Python 기반 웹 프레임워크 (FastAPI 선호).
- 프론트엔드: React + TypeScript + Vite 선호.
- 통신: HTTP + JSON REST API.
- 초기 버전의 분석 로직은 **규칙 기반(룰 기반)** 만으로도 완전히 동작해야 한다.  
  LLM(Kanana) 연동은 **나중에 끼워 넣을 수 있는 선택적 모듈**로 설계한다.

---

## 1. 문제 정의 (Problem Statement)

사용자는 카카오톡 같은 메신저에서 **두 가지 불안/위험**을 동시에 겪고 있다:

1. **보낼 때의 불안 (발신 리스크)**  
   - 신분증 사진, 통장·카드 번호, 계좌번호, 주민등록번호, 인증번호 등을  
     “한번 보내고 나면 돌이킬 수 없다”는 불안감을 느낀다.
   - 메시지 삭제 기능은 **사후 조치**에 불과하고,  
     “보내기 직전, 이게 괜찮은지”를 알려주는 기능은 부족하다.

2. **받을 때의 위협 (수신 리스크)**  
   - “엄마, 폰 고장났어”, “급하게 돈 좀 보내줘”, “인증번호 좀 알려줘” 같은  
     메신저 피싱/사칭/스미싱이 일상화되어 있다.
   - 생성형 AI로 인해 사기 메시지는 점점 더 그럴듯해지고,  
     사용자는 “이게 진짜인지, 사기인지” 스스로 판단하기 어려워진다.

**Kanana DualGuard**의 목적은:

> “메신저 위에 얹힌 하나의 ‘보안 에이전트 레이어’를 만들어,  
> **보낼 때의 불안**과 **받을 때의 위협**을 동시에 줄이는 것”이다.

---

## 2. 제품 비전 (Product Vision)

Kanana DualGuard POC는 다음과 같은 **단일 문장 비전**을 따른다:

> “카카오톡 스타일 채팅 환경에서,  
> 사용자가 **민감한 정보를 보낼 때는 미리 막아주고**,  
> **수상한 메시지를 받을 때는 먼저 의심해주는**  
> 양방향 보안 에이전트 데모를 구현한다.”

이 POC는:

- **실제 카카오톡에 붙기 전 단계**의 웹 기반 데모다.
- 투자자/기획자/엔지니어가 보고:
  - “이 에이전트를 카톡에 넣으면 어떤 UX가 되는지”
  - “어떤 리스크를 줄여줄 수 있는지”
- 를 **직접 체험**할 수 있도록 만드는 것이 목표다.

---

## 3. 핵심 개념 (Core Concepts)

이 프로젝트는 본질적으로 두 개의 에이전트를 가진다.

### 3.1 안심 전송 Agent (Outgoing Safety Agent)

**상황:**  
사용자가 메시지를 **보내기 직전**.

**역할:**

- 메시지 내용(텍스트 기준, 추후 이미지/OCR 확장)을 분석해 **PII/민감정보**를 감지한다.
- 감지 결과와 간단한 규칙을 통해 **위험도**를 평가한다.
- 위험도가 일정 수준 이상이면,  
  “이 메시지는 **시크릿 전송(Secret Send)** 으로 보내는 것이 더 안전하다”고 **제안**한다.
- 시크릿 전송이 선택되면:
  - 평문으로 보내는 대신 “시크릿 링크/토큰” 등으로 대체하는 컨셉을 시각적으로 보여준다  
    (실제 암호화 구현은 POC에서는 단순화 가능).

**이 Agent가 반드시 하는 일(POC 기준):**

- 계좌번호 / 주민등록번호 / 카드번호 / 전화번호 등 **패턴을 인식**한다.
- “이 메시지는 그냥 보내도 괜찮은지, 더 안전하게 보내야 하는지”에 대해  
  **사용자에게 한 번 더 생각할 기회를 준다.**

---

### 3.2 안심 가드 Agent (Incoming Safety Agent)

**상황:**  
사용자가 새로운 메시지를 **받았을 때**.

**역할:**

- 메시지의 텍스트를 분석해,
  - 가족/지인 사칭,
  - 급전/송금 요구,
  - 피싱 링크,
  - 인증번호 탈취
  등의 **사기/피싱 패턴**을 탐지한다.
- 탐지 결과를 바탕으로 **위험도**를 평가한다.
- 위험도에 따라:
  - 단순 정보 제공(“처음 보는 계좌입니다”)
  - 경고(노란 배너)
  - 강력 경고 또는 차단(빨간 배너/메시지 숨김)
  중 하나를 UI로 표시한다.

**이 Agent가 반드시 하는 일(POC 기준):**

- “엄마, 폰 고장났어” 류의 사칭 패턴,
- “계좌번호, 지금 바로 송금” 류의 급전 요청,
- “아래 링크로 로그인/인증” 류의 피싱 패턴을 **룰 기반으로라도 감지**한다.
- 사용자에게
  - “이건 평범한 메시지일 가능성이 크다” vs
  - “이건 조금 수상하다” vs
  - “이건 매우 위험해 보인다”
  를 직관적으로 전달한다.

---

## 4. 사용자 경험 (UX) 요구사항

### 4.1 OUTGOING 플로우 — “보내기 전에 말려주는 친구”

**필수 시나리오:**

1. 사용자가 채팅 입력창에 메시지를 입력한다.  
   예:  
   - “이 계좌로 30만원 보내줘 123-45-67890”  
   - “주민번호 900101-1****** 이거야”

2. “보내기” 버튼을 눌렀을 때,  
   메시지는 **바로 전송되지 않고**, 먼저 **Outgoing 분석**이 수행된다.

3. 시스템은 분석 결과에 따라:
   - (a) 민감정보 없음 + 위험도 LOW →  
     - “경고 없이 바로 전송(또는 전송 시뮬레이션)”  
   - (b) 민감정보 있음 + 위험도 MED/HIGH 이상 →  
     - 화면 상단/하단에 **배너 또는 모달**로 다음과 같은 내용을 보여준다:
       - “계좌번호/개인정보가 포함된 메시지입니다.”
       - “**시크릿 전송**으로 보내는 것이 더 안전합니다.”
       - 버튼: `[시크릿 전송으로 보내기]` `[그냥 보내기]`.

4. 사용자가 버튼을 선택하면:
   - “시크릿 전송으로 보내기”:  
     - 실제 채팅창에는 평문 대신  
       “🔒 시크릿 메시지 (열람 링크)” 같은 형태로 표시된다(시뮬레이션 OK).
   - “그냥 보내기”:  
     - 원래 내용 그대로 메시지가 채팅창에 표시된다.

**UX 목표:**

- 사용자가 “보내기”를 누른 후,
  - “아, 이거 민감했네…” 하고 뒤늦게 후회하는 상황을 줄인다.
- “경고가 너무 자주 떠서 짜증난다” 수준까지 가지 않도록,  
  **명백한 민감정보가 있을 때만 강하게 개입**하는 v0를 구현한다.

---

### 4.2 INCOMING 플로우 — “수상한 메시지를 먼저 의심해주는 경호원”

**필수 시나리오:**

1. 사용자가 새로운 메시지를 받는다 (상대방으로부터 또는 시뮬레이션).
   - 예: “엄마 폰이 갑자기 고장나서 번호 바뀜. 지금 이 계좌로 300만 빨리 보내줄 수 있어?”

2. 메시지가 도착하면, 시스템은 자동으로 **Incoming 분석**을 수행하거나,  
   최소한 사용자가 “위험도 확인” 버튼을 눌렀을 때 분석을 수행한다.

3. 분석 결과에 따라:

   - (a) 위험도 LOW:
     - 별도의 경고 없이, 일반 메시지처럼 보여준다.
     - 선택적으로 “이 메시지는 특별한 위험 패턴이 감지되지 않았습니다” 정도의 작은 표시 가능.

   - (b) 위험도 MEDIUM:
     - 메시지 위/아래에 노란색 정보/경고 배너:
       - “가족/지인을 사칭하는 패턴이 일부 감지되었습니다.”
       - “계좌/송금 요청이 포함되어 있습니다. 주의하세요.”

   - (c) 위험도 HIGH/CRITICAL:
     - 강렬한 경고:
       - “이 메시지는 사기일 가능성이 매우 높습니다.”
       - “발신자 정보와 내용이 일반적인 피싱 패턴과 유사합니다.”
     - 기본 동작:
       - 메시지 본문을 흐리게 처리하거나 숨기고,
       - “[위험을 감수하고 보기]” 버튼을 제공.

4. 사용자의 선택(무시/보기/차단 등)은 추후 모델/정책 개선에 활용될 수 있는 신호가 될 수 있도록 설계(로그/이벤트 수준).

**UX 목표:**

- “사용자가 스스로 의심하지 못할 만한 메시지”에서,  
  시스템이 대신 **의심의 출발점**을 제공한다.
- 너무 자주 경고를 띄워, 사용자가 “이 시스템은 무시하는 게 낫겠다”라고 느끼지 않도록 한다.

---

## 5. 시스템 행동 요구사항 (Functional Behavior)

아래 요구사항은 **구현 방식과 무관하게** 반드시 충족되어야 한다.

### 5.1 공통

- 시스템은 최소한 다음 정보를 기반으로 분석을 수행한다:
  - 메시지 본문 텍스트
  - 발신자 ID
  - 수신자 ID
- 분석 결과는:
  - **위험도 (`RiskLevel`)**
  - **설명 가능한 이유 (하나 이상의 human-readable 문자열)**
  를 포함해야 한다.
- POC에서는 실제 데이터베이스/외부 API를 사용하지 않고 **룰 기반·가짜 데이터**로 동작해도 괜찮지만,  
  구조적으로는 나중에 다음을 붙일 수 있어야 한다:
  - Kanana LLM
  - 사기 계좌/번호 DB
  - Social Graph 정보
  - 정책/설정 저장소

### 5.2 Outgoing 분석 엔진

- 필수:
  - 전화번호/계좌/주민번호/카드번호 패턴을 탐지할 수 있어야 한다.
  - 탐지 결과를 기반으로 “위험도”를 최소 2단계 이상(Low/Medium/High)으로 나눌 수 있어야 한다.
  - “시크릿 전송 추천 여부”와 그 이유를 사용자에게 전달할 수 있어야 한다.

- 선택/확장:
  - LLM을 통해 메시지의 맥락(예: “농담으로 쓴 계좌”, “테스트용 계좌”)을 파악하고 위험도를 조정할 수 있도록 구조를 열어둔다.

### 5.3 Incoming 분석 엔진

- 필수:
  - 가족 사칭/급전 요청/피싱 링크에 대한 기본적인 문자열 패턴 탐지.
  - 탐지 결과를 `ScamType` 과 `reasons` 형태로 표현.
  - `risk_level` 과 `recommended_action` 을 결정하는 간단한 규칙 기반 로직.

- 선택/확장:
  - LLM을 이용해 “이 대화가 기존 대화들과 얼마나 다른지”, “일반적인 사기 템플릿과 얼마나 유사한지” 등을 평가할 수 있도록 Hook 제공.

---

## 6. 비기능 요구사항 (Non-Functional)

- **데모 친화성:**  
  - 초기 POC는 노트북 한 대에서 실행 가능한 수준으로 가볍게 동작해야 한다.
  - 예: 백엔드/프론트엔드 각각 로컬 서버로 구동.

- **설명 가능성:**  
  - 각 판단에는 사람이 읽을 수 있는 “이유(reason)” 문자열이 포함되어야 한다.
  - 이유는 그대로 UI에 노출될 수 있도록 과도한 전문 용어를 피한다.

- **확장 가능성:**  
  - 룰 기반 로직을 나중에 Kanana LLM 분석 결과로 대체/보완하기 쉽도록,  
    “규칙/모델/정책”을 한 객체/모듈 안에 하드코딩하지 말고,  
    **레이어를 나누고 인터페이스를 분리하는 구조**를 지향한다.

---

## 7. 구현 자유도에 대한 명시

- 이 문서는 **“무엇을 만들 것인가”**를 정의하며,  
  **“어떻게 디렉터리를 나눌 것인가, 파일 이름을 무엇으로 할 것인가”**는 정의하지 않는다.
- 단, 어떤 구조를 선택하더라도:
  - OUTGOING/INCOMING 두 흐름이 분리되어 이해될 수 있어야 하고,
  - 프론트엔드가 백엔드에게 **분석 요청 → 분석 결과 수신 → UI 반영**을 쉽게 할 수 있어야 한다.
- 당신(AI)은 위 목적과 행동 요구사항을 달성하는 선에서  
  가장 단순하고 유지보수하기 쉬운 구조를 스스로 설계해도 된다.

---

이 명세의 핵심은:

1. **왜 이 시스템이 필요한지**,  
2. **사용자가 어떤 도움을 받는지**,  
3. **각 Agent가 어떤 결정을 내리는지**

를 이해하고 구현하는 것이다.  
구체적인 폴더 구조나 도구 선택은 이 목적을 방해하지 않는 선에서 자유롭게 선택하라.

---

## 8. Current Implementation Architecture

이 프로젝트는 **3-Tier Architecture**로 구현되었습니다:

1.  **Frontend Client (React)**
    - **Port**: `3000`
    - **Path**: `frontend/KakaoTalk/client`
    - **Role**: 사용자 UI/UX

2.  **Frontend Server (Node.js)**
    - **Port**: `8001`
    - **Path**: `frontend/KakaoTalk/server`
    - **Role**: 메인 서버 (API, Socket.io, DB)

3.  **Backend (Python/FastAPI)**
    - **Port**: `8002`
    - **Path**: `backend`
    - **Role**: AI 보안 분석 (Agent, LLM)
